//二叉树回顾
//结构：空二叉树、只有一个结点，根结点，左右子树，前驱，后继、父子结点、兄弟、祖先子孙
//路径、路径长度、结点层数（根层数为0）、度数012、高度（最大层数）、树叶和分支结点
//特殊的二叉树：满二叉树、完全二叉树、扩充二叉树（外部结点、内部结点、外部路径长度和内部路径长度、在一般二叉树上扩展）
//一般二叉树主要性质：1.i层上至多pow(2,i)个结点 2.高度为k，至多2**k-1个 3.n0叶结点=n2度数为2 +1
//完全二叉树性质：1.k=log2n向下取整 2.从0开始编号：0为根结点，i>0,父结点为(i-1)/2向下取整，2i+1左子结点 2i+2右子结点 当然小于n-1
//满二叉树性质：1.叶结点比分支结点多1 
//扩充二叉树性质：1.外部结点比内部结点多1 2.外部路径=内部路径+2*内部结点个数
//周游：深度优先周游(前序遍历，中序遍历，后序遍历)，广度优先周游（周游后得到层次序列）
//前序：根、左子树、右子树；中序：左子树、根、右子树 后序：左子树、右子树、根。  周游后得到二叉树一个线性序列，前驱和后继。
//已知中序序列和前（后）序序列，就能确定二叉树，知道前后没办法

//算术表达式：分支结点为运算符号，叶结点为数字，前缀中缀后缀表达式

//二叉树实现：顺序表示（数组）：广度优先、完全二叉树、一般二叉树先扩充，通过索引访问根，左右子
//链接表示，左右指针，访问父节点非常困难  线索二叉树：把第一次周游的信息存在空指针里面，左空指针指向前驱，右空指针指向后继，因此不同周游顺序的线索二叉树不同 用线索代替空指针，因此需要标志位区分

//二叉树的应用：堆（完全二叉树的种）：小根堆（根结点最小），大根堆
//优先队列(抽象数据结构)：与队列没啥关系，最小元素先出，与先后顺序无关：添加、找出最小、删除最小
//优先队列操作的实现：插入（筛选法）：逐渐上升，填补、留出空位的过程，不真正插入；删除：留出空位，空位的两个子结点与堆最后一位的比较
//哈夫曼树（最优二叉树）：扩充二叉树，只关心外部结点 外部路径长度带权值 WPL最小
//构造：哈夫曼算法 m个结点构造m个空二叉树扩充起来的扩充二叉树，选最小两个作为左右子树，根结点为和 

//树
//度数：最大 有序无序 长子和次子
//数据结构：返回右兄弟树
//周游：深度（前序、后序）和广度

//树林
//树 有序 兄弟（注意不同树的子结点不能是兄弟）
//前序 后序 去了根结点就是树林
//树与二叉树的转换
//树林到二叉树：相邻兄弟加线（所有层），保留最左边儿子的线
//二叉树到树林：左子结点的右子结点、右子的右子。。。。。。与父节点连起来，去掉原来父母到右节点的连线

class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {//第一次根的访问是特殊的，单独列出来
        List<Integer> res=new ArrayList<Integer>();
        inorder(root,res);
        return res;
    }
    public void inorder(TreeNode root, List<Integer> res){//使用递归，注意数据类型带<>
        if(root==null){
            return;
        }
        inorder(root.left,res);
        res.add(root.val);//因为每个点都会遍历到，在中间加就行了，关键是按顺序收集
        inorder(root.right,res);
    }
}
